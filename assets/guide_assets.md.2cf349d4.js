import{o as e,c as a,a as s}from"./app.6258f395.js";const n='{"title":"에셋 가져오기","description":"","frontmatter":{},"headers":[{"level":2,"title":"URL을 통해 에셋 Import 하기","slug":"url을-통해-에셋-import-하기"},{"level":3,"title":"접미사를 이용해 URL로 에셋 가져오기","slug":"접미사를-이용해-url로-에셋-가져오기"},{"level":3,"title":"문자열 형태로 에셋 가져오기","slug":"문자열-형태로-에셋-가져오기"},{"level":3,"title":"스크립트를 Worker로 가져오기","slug":"스크립트를-worker로-가져오기"},{"level":2,"title":"public 디렉터리","slug":"public-디렉터리"}],"relativePath":"guide/assets.md","lastUpdated":1623432586014}',o={},p=s('<h1 id="에셋-가져오기"><a class="header-anchor" href="#에셋-가져오기" aria-hidden="true">#</a> 에셋 가져오기</h1><p>다음 두 개의 주제와 관련있는 섹션입니다.</p><ul><li><a href="./build.html#public-base-path">Public Base Path</a></li><li><a href="/config/#assetsinclude"><code>assetsInclude</code> config option</a></li></ul><h2 id="url을-통해-에셋-import-하기"><a class="header-anchor" href="#url을-통해-에셋-import-하기" aria-hidden="true">#</a> URL을 통해 에셋 Import 하기</h2><p>정적 에셋을 Import하게 되면 에셋에 접근할 수 있는 URL이 반환됩니다.</p><div class="language-js"><pre><code><span class="token keyword">import</span> imgUrl <span class="token keyword">from</span> <span class="token string">&#39;./img.png&#39;</span>\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;hero-img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> imgUrl\n</code></pre></div><p>예를 들어, <code>imgUrl</code> 객체는 개발 시 <code>/img.png</code> 값으로 할당되겠으나, 실제 배포 버전에서는 <code>/assets/img.2d8efhg.png</code>와 같은 값*이 할당됩니다. (* 여기서 <code>2d8efhg</code>는 해시 값을 의미합니다.)</p><p>Webpack의 <code>file-loader</code>와 비슷한데, 하나 차이점이 있다면 Vite은 절대 경로와 상대 경로 둘 다 사용할 수 있습니다.</p><ul><li><p><code>url()</code>로 참조되는 CSS의 경우 동일한 방식으로 동작합니다.</p></li><li><p>만약 Vue 플러그인을 사용한다면, <a href="https://v3.vuejs.org/guide/single-file-component.html" target="_blank" rel="noopener noreferrer">Vue SFC</a> 에셋의 경우 자동으로 변환되어 Import 됩니다.</p></li><li><p>일반적인 이미지, 미디어, 폰트 파일 타입은 자동으로 에셋 목록에 포함됩니다. 물론 <a href="/config/#assetsinclude"><code>assetsInclude</code> 옵션</a>을 이용해 더 많은 파일 타입을 포함하도록 할 수 있습니다.</p></li><li><p>참조된 에셋은 빌드 에셋 그래프의 일부 요소로 포함되며, 파일 이름이 해싱되거나 최적화를 위해 플러그인으로 처리될 수 있습니다.</p></li><li><p><a href="/config/#assetsinlinelimit"><code>assetsInlineLimimt</code> 옵션</a>의 값보다 작은 에셋 파일의 경우, Base64 포맷의 데이터 URL* 문자열로 가져옵니다. (* <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" target="_blank" rel="noopener noreferrer">데이터 URL MDN doc</a>)</p></li></ul><h3 id="접미사를-이용해-url로-에셋-가져오기"><a class="header-anchor" href="#접미사를-이용해-url로-에셋-가져오기" aria-hidden="true">#</a> 접미사를 이용해 URL로 에셋 가져오기</h3><p><code>assetsInclude</code> 옵션 또는 URL로 가져오도록 Vite 내부적으로 설정된 리스트에 포함되지 않은 에셋의 경우에도 URL 포맷으로 에셋을 가져오도록 지정할 수 있습니다. <code>?url</code> 접미사(Suffix)를 붙여 에셋을 가져오면 되는데, 예를 하나 들어보자면 다음과 같습니다.</p><div class="language-js"><pre><code><span class="token keyword">import</span> workletURL <span class="token keyword">from</span> <span class="token string">&#39;extra-scalloped-border/worklet.js?url&#39;</span>\n<span class="token constant">CSS</span><span class="token punctuation">.</span>paintWorklet<span class="token punctuation">.</span><span class="token function">addModule</span><span class="token punctuation">(</span>workletURL<span class="token punctuation">)</span>\n</code></pre></div><h3 id="문자열-형태로-에셋-가져오기"><a class="header-anchor" href="#문자열-형태로-에셋-가져오기" aria-hidden="true">#</a> 문자열 형태로 에셋 가져오기</h3><p><code>?raw</code> 접미사를 붙여 Import하는 에셋은 문자열 형태로 가져와지게 됩니다.</p><div class="language-js"><pre><code><span class="token keyword">import</span> shaderString <span class="token keyword">from</span> <span class="token string">&#39;./shader.glsl?raw&#39;</span>\n</code></pre></div><h3 id="스크립트를-worker로-가져오기"><a class="header-anchor" href="#스크립트를-worker로-가져오기" aria-hidden="true">#</a> 스크립트를 Worker로 가져오기</h3><p>스크립트는 웹 워커로 가져올 수 있는데, 이 때는 <code>?worker</code> 접미사를 이용합니다.</p><div class="language-js"><pre><code><span class="token comment">// 배포 시에는 청크로 분리됩니다.</span>\n<span class="token keyword">import</span> Worker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?worker&#39;</span>\n<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// `inline` 접미사는 Base64 포맷의 문자열로 에셋을 가져옵니다.</span>\n<span class="token keyword">import</span> InlineWorker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?worker&amp;inline&#39;</span>\n</code></pre></div><p>좀 더 자세한 사항은 <a href="./features.html#web-workers">웹 워커 섹션</a>을 참고해주세요.</p><h2 id="public-디렉터리"><a class="header-anchor" href="#public-디렉터리" aria-hidden="true">#</a> <code>public</code> 디렉터리</h2><p>다음 에셋의 경우</p><ul><li><code>robots.txt</code>와 같이 소스 코드에서 참조되지 않는 에셋</li><li>해싱 없이 항상 같은 이름을 갖는 에셋</li><li>또는 URL을 얻기 위해 굳이 Import 할 필요 없는 에셋</li></ul><p><code>public</code> 디렉터리 아래에 에셋을 위치시키세요. 이 곳에 위치한 에셋은 개발 시에 <code>/</code> 경로에, 배포 시에는 <code>dist</code> 디렉터리에 위치하게 됩니다.</p><p>만약 <code>&lt;root&gt;/public</code> 디렉터리가 아닌 다른 디렉터리를 사용하고자 하는 경우, <a href="/config/#publicdir"><code>publicDir</code> 옵션</a>을 이용할 수 있습니다.</p><p>마지막으로, 다음의 사항을 유의해주세요.</p><ul><li><code>public</code> 디렉터리에 위치해 있는 에셋을 가져오고자 하는 경우, 항상 루트를 기준으로 하는 절대 경로로 가져와야만 합니다. ( <code>public/icon.png</code> 에셋은 소스 코드에서 <code>/icon.png</code>으로 접근이 가능합니다.)</li><li><code>public</code> 디렉터리에 위치한 에셋은 JavaScript 코드로 가져올 수 없습니다.</li></ul>',27);o.render=function(s,n,o,r,l,c){return e(),a("div",null,[p])};export default o;export{n as __pageData};
